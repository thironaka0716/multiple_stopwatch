<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>マルチタスクストップウォッチ (Flex, Wider Inputs)</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    /* ==== ベースCSS ==== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Inter', sans-serif;
      background: #f9f9f9;
      color: #333;
      padding: 30px;
      min-height: 100vh;
      position: relative;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-weight: 600;
      color: #444;
    }

    /* ==== コンテナ ==== */
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      padding: 20px 20px 30px;
      position: relative;
    }

    /* ==== 手動で保存ボタン (右上端固定) ==== */
    .manual-save-btn {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 0.5rem 1rem;
      background: #666;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      z-index: 9999;
    }
    .manual-save-btn:hover {
      background: #555;
    }

    /* ==== コントロールパネル ==== */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
    }
    .controls input {
      padding: 0.6rem 0.8rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.2s;
    }
    .controls input:focus {
      border-color: #66aaff;
    }
    .controls button {
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      background: #66aaff;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }
    .controls button:hover {
      background: #5595dd;
    }

    /* スマホ幅でコントロールを縦並びに */
    @media (max-width: 600px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      .controls input,
      .controls button {
        width: 100%;
      }
    }

    /* ==== カテゴリー一覧 (縦) ==== */
    #categories-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* ==== カテゴリーカード ==== */
    .category-card {
      background: #eee;
      border-radius: 8px;
      padding: 10px;
      position: relative;
      user-select: none;
    }
    .category-card.drag-over {
      outline: 2px dashed #66aaff;
    }

    /* カテゴリヘッダー */
    .category-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
      cursor: move;
    }
    .cat-handle {
      width: 20px;
      text-align: center;
      font-size: 1rem;
      flex-shrink: 0;
      cursor: move;
    }
    .cat-info {
      display: flex;
      align-items: center;
      flex: 1;
      gap: 8px;
      min-width: 0;
      overflow: hidden;
    }
    .cat-toggle-btn {
      background: transparent;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
    }
    .cat-name {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .cat-right {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    /* カラーパレット */
    .color-palette {
      position: relative;
    }
    .color-palette-btn {
      background: #ddd;
      border: none;
      border-radius: 6px;
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .color-palette-btn:hover {
      background: #ccc;
    }
    .color-preview {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      margin-left: 5px;
      display: inline-block;
      vertical-align: middle;
    }
    .color-palette-popup {
      display: none;
      position: absolute;
      top: 28px;
      left: 0;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 8px;
      z-index: 1000;
      width: 140px;
    }
    .color-palette.open .color-palette-popup {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .color-swatch:hover {
      border-color: #666;
    }

    /* +ボタン */
    .cat-add-btn {
      background: #5cb85c;
      border: none;
      border-radius: 6px;
      padding: 0.3rem 0.8rem;
      color: #fff;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .cat-add-btn:hover {
      background: #4cae4c;
    }

    /* タスクリスト (横並び, wrap) */
    .task-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    /* ==== タスクカード ==== */
    .task-card {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      user-select: none;
      display: flex;
      /* 横幅が広いときは1行,
         狭くなると wrapして2,3行 */
      flex-flow: row nowrap;
      gap: 6px;
      align-items: center;
      padding: 8px;
      cursor: move;
      /* ここを100%にすると
         横幅いっぱいに伸び、長い名前が入力しやすい */
      width: 100%;
    }
    .task-card.drag-over {
      outline: 2px dashed #66aaff;
    }

    /* ここで画面が狭い場合(例:900px以下)に2行以上に */
    @media (max-width: 900px) {
      .task-card {
        flex-flow: row wrap; 
      }
    }

    .task-handle {
      width: 20px;
      text-align: center;
      font-size: 1rem;
      flex-shrink: 0;
      cursor: move;
    }

    /* カテゴリ欄, タスク名, 時間, ボタンをflex要素に */
    /* 幅を固定せず、伸縮できるようにflex:1 */
    .task-cat {
      flex: 1 1 100px; 
      min-width: 80px;
    }
    .task-name {
      flex: 2 1 200px; 
      min-width: 120px; 
    }
    .time-display {
      flex: 0 1 auto;
      min-width: 60px;
      font-family: monospace;
      font-weight: 600;
      font-size: 0.9rem;
      text-align: center;
    }
    .btn-group {
      display: flex;
      flex-shrink: 0;
      gap: 4px;
    }
    .btn-group button {
      border: none;
      border-radius: 6px;
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      cursor: pointer;
      color: #fff;
    }
    .start-btn { background: #66aaff; }
    .start-btn:hover { background: #5595dd; }
    .stop-btn { background: #d9534f; }
    .stop-btn:hover { background: #c9302c; }
    .reset-btn { background: #f0ad4e; }
    .reset-btn:hover { background: #d99640; }
    .delete-btn { background: #d9534f; }
    .delete-btn:hover { background: #c9302c; }

    /* スマホ幅でさらに縮小 */
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      h1 {
        margin-bottom: 10px;
        font-size: 1.2rem;
      }
      .container {
        padding: 10px;
      }
      .controls input, .controls button {
        padding: 0.4rem 0.6rem;
        font-size: 0.8rem;
      }
      .cat-handle, .task-handle {
        width: 16px;
        font-size: 0.9rem;
      }
      .task-cat { min-width: 60px; }
      .task-name { min-width: 80px; }
      .time-display {
        font-size: 0.8rem;
        min-width: 50px;
      }
      .btn-group button {
        font-size: 0.7rem;
        padding: 0.2rem 0.4rem;
      }
    }

  </style>
</head>
<body>

<h1>マルチタスクストップウォッチ (Wider Inputs)</h1>

<button id="manualSaveBtn" class="manual-save-btn">手動で保存</button>

<div class="container">

  <div class="controls">
    <input type="text" id="categoryInput" list="categorySuggestions" placeholder="カテゴリー" />
    <datalist id="categorySuggestions"></datalist>

    <input type="text" id="taskNameInput" placeholder="タスク名" />
    <button id="addTaskBtn">＋タスク追加</button>

    <button id="stopAllBtn">STOP ALL</button>
    <button id="resetAllBtn">RESET ALL</button>
  </div>

  <div id="categories-container"></div>

</div>

<script>
/* ==================================================
   データ & 変数
================================================== */
let tasks = [];
let collapsedCategories = {};
let knownCategories = [];
let categoryOrder = [];
let categoryColors = {};

const STORAGE_KEY = 'multiTaskStopwatchData_final';

const PRESET_COLORS = [
  "#F94144","#F3722C","#F8961E","#F9844A","#F9C74F",
  "#90BE6D","#43AA8B","#4D908E","#577590","#277DA1",
  "#64C3EE","#6367A9","#B986C8","#F48FB1","#FFB5E8",
  "#FFDAC1","#B5EAD7","#C7CEEA","#FF9CEE","#F6B7C6"
];

/* DOM */
const manualSaveBtn = document.getElementById('manualSaveBtn');
const categoryInput = document.getElementById('categoryInput');
const taskNameInput = document.getElementById('taskNameInput');
const addTaskBtn = document.getElementById('addTaskBtn');
const stopAllBtn = document.getElementById('stopAllBtn');
const resetAllBtn = document.getElementById('resetAllBtn');
const categoriesContainer = document.getElementById('categories-container');
const categorySuggestions = document.getElementById('categorySuggestions');

let globalTimerId = null;

/* ==================================================
   localStorage
================================================== */
function saveToLocalStorage(){
  try {
    const data = { tasks, collapsedCategories, knownCategories, categoryOrder, categoryColors };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    console.log("Saved to localStorage.");
  } catch(e){
    console.warn("Saving localStorage failed:", e);
  }
}

function loadFromLocalStorage(){
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if(!saved) return;
    const parsed = JSON.parse(saved);
    if(parsed.tasks) tasks=parsed.tasks;
    if(parsed.collapsedCategories) collapsedCategories=parsed.collapsedCategories;
    if(parsed.knownCategories) knownCategories=parsed.knownCategories;
    if(parsed.categoryOrder) categoryOrder=parsed.categoryOrder;
    if(parsed.categoryColors) categoryColors=parsed.categoryColors;
  } catch(e){
    console.warn("Loading localStorage failed:", e);
  }
}

/* ==================================================
   カテゴリ管理
================================================== */
function addKnownCategory(cat){
  if(cat && !knownCategories.includes(cat)){
    knownCategories.push(cat);
  }
}
function getOrderedCategories(){
  const usedCats=[...new Set(tasks.map(t=>t.category))];
  let ordered=categoryOrder.filter(c=>usedCats.includes(c));
  usedCats.forEach(c=>{
    if(!ordered.includes(c)){
      ordered.push(c);
    }
  });
  categoryOrder=ordered;
  return ordered;
}
function reorderCategories(fromIndex,toIndex){
  if(fromIndex===toIndex)return;
  const moved=categoryOrder.splice(fromIndex,1)[0];
  categoryOrder.splice(toIndex,0,moved);
  renderAll();
  saveToLocalStorage();
}
function toggleCategoryCollapse(cat){
  collapsedCategories[cat]=!collapsedCategories[cat];
  renderAll();
  saveToLocalStorage();
}
function getCategoryColor(cat){
  return categoryColors[cat]||'#e0e0e0';
}
function setCategoryColor(cat, colVal){
  categoryColors[cat]=colVal;
  saveToLocalStorage();
  renderAll();
}

/* ==================================================
   カテゴリ掃除/自動色
================================================== */
function cleanupCategories(){
  const usedCats= new Set(tasks.map(t=>t.category));
  knownCategories= knownCategories.filter(c=> usedCats.has(c) && c!=='');
  categoryOrder= categoryOrder.filter(c=> usedCats.has(c));
  for(const c in categoryColors){
    if(!usedCats.has(c)){
      delete categoryColors[c];
    }
  }
  for(const c in collapsedCategories){
    if(!usedCats.has(c)){
      delete collapsedCategories[c];
    }
  }
  for(const c of usedCats){
    if(c!=='' && !categoryColors[c]){
      autoAssignColor(c);
    }
  }
}
function autoAssignColor(cat){
  if(categoryColors[cat]) return;
  const used=new Set(Object.values(categoryColors));
  for(const col of PRESET_COLORS){
    if(!used.has(col)){
      categoryColors[cat]=col;
      return;
    }
  }
  categoryColors[cat]=PRESET_COLORS[0]||'#e0e0e0';
}

/* ==================================================
   タスク操作
================================================== */
function addTask(cat,name){
  const c=cat||'';
  const nm=name||'';
  if(!collapsedCategories.hasOwnProperty(c)){
    collapsedCategories[c]=false;
  }
  addKnownCategory(c);
  if(!categoryOrder.includes(c)){
    categoryOrder.push(c);
  }
  tasks.push({
    id:Date.now(),
    category:c,
    name:nm,
    startTime:0,
    elapsedTime:0,
    running:false
  });
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}
function deleteTask(id){
  tasks=tasks.filter(t=>t.id!==id);
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}
function toggleTask(id){
  const task= tasks.find(t=>t.id===id);
  if(!task)return;
  if(!task.running){
    task.running=true;
    task.startTime=Date.now();
    startGlobalTimer();
  } else {
    const now=Date.now();
    task.elapsedTime+=(now-task.startTime);
    task.running=false;
  }
  renderAll();
  saveToLocalStorage();
}
function resetTask(id){
  const task= tasks.find(t=>t.id===id);
  if(!task)return;
  task.running=false;
  task.elapsedTime=0;
  task.startTime=0;
  renderAll();
  saveToLocalStorage();
}
function changeTaskCategoryInline(task,newCat){
  task.category=newCat;
  if(!collapsedCategories.hasOwnProperty(newCat)){
    collapsedCategories[newCat]=false;
  }
  addKnownCategory(newCat);
  if(!categoryOrder.includes(newCat)){
    categoryOrder.push(newCat);
  }
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}

/* ==================================================
   並べ替え
================================================== */
function reorderTasksInCategory(cat, fromIndex,toIndex){
  if(fromIndex===toIndex)return;
  let catTasks= tasks.filter(t=>t.category===cat);
  if(fromIndex<0||fromIndex>=catTasks.length)return;
  if(toIndex<0||toIndex>catTasks.length)return;
  const [moved]= catTasks.splice(fromIndex,1);
  catTasks.splice(toIndex,0,moved);
  let rest= tasks.filter(t=>t.category!==cat);
  rest.push(...catTasks);
  tasks=rest;
  renderAll();
  saveToLocalStorage();
}
function moveTaskToCategory(taskId,newCat,newIndex=null){
  const task= tasks.find(t=>t.id===taskId);
  if(!task)return;
  const oldCat=task.category;

  let oldCatTasks= tasks.filter(t=> t.category===oldCat && t.id!==taskId);
  let newCatTasks= tasks.filter(t=> t.category===newCat);

  task.category=newCat;
  if(!collapsedCategories.hasOwnProperty(newCat)){
    collapsedCategories[newCat]=false;
  }
  addKnownCategory(newCat);
  if(!categoryOrder.includes(newCat)){
    categoryOrder.push(newCat);
  }

  if(newIndex===null||newIndex<0||newIndex>newCatTasks.length){
    newCatTasks.push(task);
  } else {
    newCatTasks.splice(newIndex,0,task);
  }
  let rest= tasks.filter(t=> t.category!==oldCat && t.category!==newCat);
  rest.push(...oldCatTasks);
  rest= rest.filter(t=> t.category!==newCat);
  rest.push(...newCatTasks);

  tasks=rest;
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}

/* ==================================================
   時間表示
================================================== */
function formatTime(msTotal){
  const ms= msTotal%1000;
  const sec=Math.floor(msTotal/1000)%60;
  const min=Math.floor(msTotal/60000);
  const mm= String(min).padStart(2,'0');
  const ss= String(sec).padStart(2,'0');
  const mss=String(ms).padStart(3,'0');
  return `${mm}:${ss}.${mss}`;
}

/* ==================================================
   全STOP / 全RESET
================================================== */
function stopAllTasks(){
  const now=Date.now();
  tasks.forEach(t=>{
    if(t.running){
      t.elapsedTime+=(now-t.startTime);
      t.running=false;
    }
  });
  renderAll();
  saveToLocalStorage();
}
function resetAllTasks(){
  tasks.forEach(t=>{
    t.running=false;
    t.elapsedTime=0;
    t.startTime=0;
  });
  renderAll();
  saveToLocalStorage();
}

/* ==================================================
   画面描画
================================================== */
function renderAll(){
  categoriesContainer.innerHTML='';

  cleanupCategories();
  const categories= getOrderedCategories();

  categories.forEach((cat, catIndex)=>{
    // カテゴリカード
    const catCard=document.createElement('div');
    catCard.className='category-card';
    catCard.draggable=true;

    // ドラッグ
    catCard.addEventListener('dragstart', e=>{
      e.dataTransfer.setData('type','category');
      e.dataTransfer.setData('fromIndex', String(catIndex));
    });
    catCard.addEventListener('dragover', e=>{
      e.preventDefault();
      const dragType=e.dataTransfer.getData('type');
      if(dragType==='category' || dragType==='task'){
        catCard.classList.add('drag-over');
      }
    });
    catCard.addEventListener('dragleave',()=>{
      catCard.classList.remove('drag-over');
    });
    catCard.addEventListener('drop', e=>{
      e.preventDefault();
      catCard.classList.remove('drag-over');
      const dragType=e.dataTransfer.getData('type');
      if(dragType==='category'){
        const fromIndex=parseInt(e.dataTransfer.getData('fromIndex'),10);
        reorderCategories(fromIndex,catIndex);
      } else if(dragType==='task'){
        const tid=parseInt(e.dataTransfer.getData('taskId'),10);
        moveTaskToCategory(tid, cat, null);
      }
    });

    // カテゴリヘッダー
    const catHeader=document.createElement('div');
    catHeader.className='category-header';
    catHeader.style.backgroundColor= getCategoryColor(cat);

    // (1) ハンドル
    const handleDiv=document.createElement('div');
    handleDiv.className='cat-handle';
    handleDiv.textContent='≡';
    catHeader.appendChild(handleDiv);

    // (2) 左(折りたたみ + 名前)
    const catInfo=document.createElement('div');
    catInfo.className='cat-info';

    const toggleBtn=document.createElement('button');
    toggleBtn.className='cat-toggle-btn';
    toggleBtn.textContent= collapsedCategories[cat]?'▶':'▼';
    toggleBtn.addEventListener('click',()=>{
      toggleCategoryCollapse(cat);
    });
    catInfo.appendChild(toggleBtn);

    const catNameSpan=document.createElement('span');
    catNameSpan.className='cat-name';
    catNameSpan.textContent= cat||'(未設定)';
    catInfo.appendChild(catNameSpan);

    catHeader.appendChild(catInfo);

    // (3) 右 (カラーパレット + "+"ボタン)
    const catRight=document.createElement('div');
    catRight.className='cat-right';

    // カラーパレット
    const paletteWrap=document.createElement('div');
    paletteWrap.className='color-palette';
    paletteWrap.style.position='relative';

    const colorBtn=document.createElement('button');
    colorBtn.className='color-palette-btn';
    colorBtn.textContent='Color';

    const preview=document.createElement('div');
    preview.className='color-preview';
    preview.style.backgroundColor=getCategoryColor(cat);
    colorBtn.appendChild(preview);

    const popup=document.createElement('div');
    popup.className='color-palette-popup';
    PRESET_COLORS.forEach(col=>{
      const swatch=document.createElement('div');
      swatch.className='color-swatch';
      swatch.style.backgroundColor=col;
      swatch.addEventListener('click',()=>{
        setCategoryColor(cat,col);
        preview.style.backgroundColor=col;
        paletteWrap.classList.remove('open');
      });
      popup.appendChild(swatch);
    });
    paletteWrap.appendChild(colorBtn);
    paletteWrap.appendChild(popup);

    colorBtn.addEventListener('click',(e)=>{
      e.stopPropagation();
      paletteWrap.classList.toggle('open');
    });
    document.addEventListener('click',(evt)=>{
      if(!paletteWrap.contains(evt.target)){
        paletteWrap.classList.remove('open');
      }
    });

    catRight.appendChild(paletteWrap);

    // +ボタン => 新タスク
    const plusBtn=document.createElement('button');
    plusBtn.className='cat-add-btn';
    plusBtn.textContent='+';
    plusBtn.addEventListener('click',()=>{
      addTask(cat,'New Task');
    });
    catRight.appendChild(plusBtn);

    catHeader.appendChild(catRight);

    catCard.appendChild(catHeader);

    // タスク一覧
    if(!collapsedCategories[cat]){
      const taskList=document.createElement('div');
      taskList.className='task-list';
      const catTasks= tasks.filter(t=>t.category===cat);
      catTasks.forEach((task,indexInCat)=>{
        const taskDiv=document.createElement('div');
        taskDiv.className='task-card';
        taskDiv.draggable=true;
        taskDiv.style.backgroundColor=getCategoryColor(cat);

        // ドラッグ
        taskDiv.addEventListener('dragstart', e=>{
          e.dataTransfer.setData('type','task');
          e.dataTransfer.setData('taskId',String(task.id));
          e.dataTransfer.setData('fromCategory', cat);
          e.dataTransfer.setData('fromIndex',String(indexInCat));
        });
        taskDiv.addEventListener('dragover', e=>{
          e.preventDefault();
          if(e.dataTransfer.getData('type')==='task'){
            taskDiv.classList.add('drag-over');
          }
        });
        taskDiv.addEventListener('dragleave', ()=>{
          taskDiv.classList.remove('drag-over');
        });
        taskDiv.addEventListener('drop', e=>{
          e.preventDefault();
          taskDiv.classList.remove('drag-over');
          if(e.dataTransfer.getData('type')==='task'){
            const fromCat=e.dataTransfer.getData('fromCategory');
            const fromIndex=parseInt(e.dataTransfer.getData('fromIndex'),10);
            const tid=parseInt(e.dataTransfer.getData('taskId'),10);
            if(fromCat===cat){
              reorderTasksInCategory(cat, fromIndex, indexInCat);
            } else {
              moveTaskToCategory(tid,cat,indexInCat);
            }
          }
        });

        // (1) ハンドル(≡)
        const taskHandle=document.createElement('div');
        taskHandle.className='task-handle';
        taskHandle.textContent='≡';
        taskDiv.appendChild(taskHandle);

        // (2) カテゴリ (inline)
        const catInput=document.createElement('input');
        catInput.type='text';
        catInput.className='inline-input task-cat';
        catInput.value=task.category;
        catInput.setAttribute('list','categorySuggestions');
        catInput.addEventListener('change',()=>{
          changeTaskCategoryInline(task, catInput.value);
        });
        taskDiv.appendChild(catInput);

        // (3) タスク名
        const nameInput=document.createElement('input');
        nameInput.type='text';
        nameInput.className='inline-input task-name';
        nameInput.value=task.name;
        nameInput.addEventListener('change',()=>{
          task.name=nameInput.value;
          saveToLocalStorage();
        });
        taskDiv.appendChild(nameInput);

        // (4) 時間
        const timeDiv=document.createElement('div');
        timeDiv.className='time-display';
        if(task.running){
          const now=Date.now();
          timeDiv.textContent=formatTime(task.elapsedTime + (now-task.startTime));
        } else {
          timeDiv.textContent=formatTime(task.elapsedTime);
        }
        taskDiv.appendChild(timeDiv);

        // (5) ボタン
        const btnGroup=document.createElement('div');
        btnGroup.className='btn-group';

        const startStopBtn=document.createElement('button');
        if(task.running){
          startStopBtn.className='stop-btn';
          startStopBtn.textContent='STOP';
        } else {
          startStopBtn.className='start-btn';
          startStopBtn.textContent='START';
        }
        startStopBtn.addEventListener('click',()=>{
          toggleTask(task.id);
        });
        btnGroup.appendChild(startStopBtn);

        const resetBtn=document.createElement('button');
        resetBtn.className='reset-btn';
        resetBtn.textContent='RESET';
        resetBtn.addEventListener('click',()=>{
          resetTask(task.id);
        });
        btnGroup.appendChild(resetBtn);

        const deleteBtn=document.createElement('button');
        deleteBtn.className='delete-btn';
        deleteBtn.textContent='削除';
        deleteBtn.addEventListener('click',()=>{
          deleteTask(task.id);
        });
        btnGroup.appendChild(deleteBtn);

        taskDiv.appendChild(btnGroup);

        taskList.appendChild(taskDiv);
      });
      catCard.appendChild(taskList);
    }

    categoriesContainer.appendChild(catCard);
  });

  updateCategorySuggestions();
}

/* === サジェスト更新 === */
function updateCategorySuggestions(){
  categorySuggestions.innerHTML='';
  knownCategories.forEach(c=>{
    const opt=document.createElement('option');
    opt.value=c;
    categorySuggestions.appendChild(opt);
  });
}

/* === 60fpsで時間描画 === */
function renderRunningState(){
  let anyRunning=false;
  const categories=getOrderedCategories();
  categories.forEach(cat=>{
    if(collapsedCategories[cat])return;
    const catTasks= tasks.filter(t=>t.category===cat);
    const catIndex=categoryOrder.indexOf(cat);
    const catCard= categoriesContainer.children[catIndex];
    if(!catCard)return;
    const taskList=catCard.querySelector('.task-list');
    if(!taskList)return;
    const taskCards=taskList.querySelectorAll('.task-card');
    taskCards.forEach((card, i)=>{
      const task= catTasks[i];
      if(!task) return;
      const timeDiv= card.querySelector('.time-display');
      const btnGroup= card.querySelector('.btn-group');
      const startStopBtn= btnGroup.children[0];
      if(task.running){
        anyRunning=true;
        const now=Date.now();
        timeDiv.textContent=formatTime(task.elapsedTime+(now-task.startTime));
        startStopBtn.className='stop-btn';
        startStopBtn.textContent='STOP';
      } else {
        startStopBtn.className='start-btn';
        startStopBtn.textContent='START';
      }
    });
  });
  if(!anyRunning){
    clearInterval(globalTimerId);
    globalTimerId=null;
  }
}
function startGlobalTimer(){
  if(globalTimerId)return;
  globalTimerId=setInterval(()=>{
    renderRunningState();
  },16);
}

/* === ページ閉じる => STOP === */
window.addEventListener('beforeunload',()=>{
  const now=Date.now();
  tasks.forEach(t=>{
    if(t.running){
      t.elapsedTime+=(now-t.startTime);
      t.running=false;
    }
  });
  saveToLocalStorage();
});

/* === 初期化 === */
window.addEventListener('DOMContentLoaded',()=>{
  loadFromLocalStorage();
  cleanupCategories();
  renderAll();
  if(tasks.some(t=>t.running)){
    startGlobalTimer();
  }
});

/* === イベント === */
addTaskBtn.addEventListener('click',()=>{
  const cat=categoryInput.value.trim();
  const nm=taskNameInput.value.trim();
  addTask(cat,nm);
  categoryInput.value='';
  taskNameInput.value='';
  categoryInput.focus();
});
stopAllBtn.addEventListener('click', stopAllTasks);
resetAllBtn.addEventListener('click', resetAllTasks);

manualSaveBtn.addEventListener('click',()=>{
  saveToLocalStorage();
  alert("手動で保存しました。");
});

</script>
</body>
</html>
