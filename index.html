<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>マルチタスクストップウォッチ (サブタスク追加・折りたたみ機能付)</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* ===== ベースリセット ===== */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Inter', sans-serif;
      background: #f9f9f9;
      color: #333;
      padding: 20px;
      min-height: 100vh;
      position: relative;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-weight: 600;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 20px 20px 30px;
      position: relative;
    }
    /* 手動保存ボタン */
    .manual-save-btn {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #666;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 0.9rem;
      z-index: 9999;
    }
    .manual-save-btn:hover { background: #555; }
    /* コントロールパネル */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
    }
    .controls input, .controls button, .controls select {
      padding: 0.5rem 0.8rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.2s;
    }
    .controls input:focus, .controls select:focus { border-color: #66aaff; }
    .controls button {
      background: #66aaff;
      color: #fff;
      border: none;
      cursor: pointer;
    }
    .controls button:hover { background: #5595dd; }
    /* カテゴリエリア */
    #categoriesContainer {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .category-card {
      background: #eee;
      padding: 10px;
      border-radius: 8px;
      position: relative;
      user-select: none;
    }
    .category-card.drag-over { outline: 2px dashed #66aaff; }
    .category-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
      cursor: move;
      background: #ddd;
      padding: 6px;
      border-radius: 6px;
    }
    .cat-handle { width: 20px; text-align: center; cursor: move; }
    .cat-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }
    .cat-toggle-btn {
      background: transparent;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
    }
    .cat-name {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }
    .cat-name-edit {
      padding: 2px 4px;
      border: 1px solid #999;
      border-radius: 4px;
      font-size: 0.9rem;
      flex: 1;
    }
    .cat-sum-time {
      margin-left: 10px;
      font-size: 0.85rem;
      font-family: monospace;
      font-weight: 600;
      color: #333;
    }
    .cat-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .cat-add-btn {
      background: #5cb85c;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .cat-add-btn:hover { background: #4cae4c; }
    /* カラーパレット */
    .color-palette { position: relative; }
    .color-palette-btn {
      background: #ddd;
      border: none;
      border-radius: 6px;
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .color-palette-btn:hover { background: #ccc; }
    .color-preview {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      margin-left: 5px;
      display: inline-block;
      vertical-align: middle;
    }
    .color-palette-popup {
      display: none;
      position: absolute;
      top: 28px;
      left: 0;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      padding: 8px;
      z-index: 999;
      width: 140px;
    }
    .color-palette.open .color-palette-popup {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 2px solid #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      cursor: pointer;
    }
    .color-swatch:hover { border-color: #666; }
    /* タスクリスト */
    .task-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .task-card {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      display: flex;
      flex-flow: row wrap;  /* wrap ではみ出し防止 */
      gap: 6px;
      align-items: center;
      padding: 8px;
      cursor: move;
      width: 100%;
      overflow: hidden;  /* 要素のはみ出しを防止 */
    }
    .task-card.drag-over { outline: 2px dashed #66aaff; }
    .task-handle { width: 20px; text-align: center; font-size: 1rem; flex-shrink: 0; cursor: move; }
    .task-name {
      flex: 2 1 auto;
      min-width: 150px;
      padding: 6px;
      border: 1px solid transparent;
      border-radius: 4px;
      background: #fcfcfc;
      font-size: 0.9rem;
    }
    .task-name:focus { outline: none; border-color: #66aaff; background: #fff; }
    .time-display {
      flex: 0 1 auto;
      min-width: 60px;
      font-family: monospace;
      font-weight: 600;
      font-size: 0.9rem;
      text-align: center;
    }
    .btn-group {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
    }
    .btn-group button {
      border: none;
      border-radius: 6px;
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      cursor: pointer;
      color: #fff;
    }
    .start-btn { background: #66aaff; }
    .start-btn:hover { background: #5595dd; }
    .stop-btn { background: #d9534f; }
    .stop-btn:hover { background: #c9302c; }
    .reset-btn { background: #f0ad4e; }
    .reset-btn:hover { background: #d99640; }
    .delete-btn { background: #d9534f; }
    .delete-btn:hover { background: #c9302c; }
  
    /* ===== サブタスク用 CSS ===== */
    .subtask-toggle-btn {
      background: transparent;
      border: none;
      font-size: 0.9rem;
      cursor: pointer;
      margin-top: 4px;
      margin-bottom: 4px;
    }
    .subtask-list {
      width: 100%;
      overflow-x: auto;  /* はみ出し防止 */
      margin-top: 6px;
      padding-left: 20px;
      border-left: 2px dashed #ccc;
    }
    .subtask-card {
      background: #fff;
      border-radius: 4px;
      padding: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 4px;
      flex-wrap: wrap;
    }
    .subtask-handle {
      width: 16px;
      text-align: center;
      cursor: move;
      font-size: 0.9rem;
    }
    .subtask-name {
      flex: 1 1 auto;
      min-width: 100px;
      padding: 4px;
      border: 1px solid transparent;
      border-radius: 4px;
      background: #fcfcfc;
      font-size: 0.85rem;
    }
    .subtask-name:focus {
      border-color: #66aaff;
      background: #fff;
      outline: none;
    }
    .subtask-time {
      font-family: monospace;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 50px;
      text-align: center;
    }
    .subtask-btn-group {
      display: flex;
      gap: 4px;
    }
    .subtask-btn-group button {
      border: none;
      border-radius: 4px;
      padding: 0.3rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
      color: #fff;
    }
    .subtask-start-btn { background: #66aaff; }
    .subtask-start-btn:hover { background: #5595dd; }
    .subtask-stop-btn { background: #d9534f; }
    .subtask-stop-btn:hover { background: #c9302c; }
    .subtask-reset-btn { background: #f0ad4e; }
    .subtask-reset-btn:hover { background: #d99640; }
    .subtask-delete-btn { background: #d9534f; }
    .subtask-delete-btn:hover { background: #c9302c; }
    .subtask-add-btn {
      background: #5cb85c;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 0.3rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .subtask-add-btn:hover { background: #4cae4c; }
  
    /* ===== スナップショットパネル ===== */
    .snapshot-panel {
      margin-top: 40px;
      padding: 20px;
      background: #fafafa;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    .snapshot-panel h2 { margin-bottom: 10px; }
    .snapshot-panel .snapshot-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .snapshot-panel .snapshot-controls input,
    .snapshot-panel .snapshot-controls button {
      padding: 0.5rem 0.8rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 0.9rem;
      outline: none;
    }
    .snapshot-panel .snapshot-controls button {
      background: #66aaff;
      color: #fff;
      border: none;
      cursor: pointer;
    }
    .snapshot-panel .snapshot-controls button:hover { background: #5595dd; }
    .snapshot-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .snapshot-group h3 {
      font-size: 1rem;
      margin-bottom: 6px;
    }
    .snapshot-group button {
      background: #ddd;
      border: none;
      border-radius: 6px;
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .snapshot-group button:hover { background: #ccc; }
  </style>
</head>
<body>

<h1>マルチタスクストップウォッチ (サブタスク追加・折りたたみ機能付)</h1>
<button id="manualSaveBtn" class="manual-save-btn">手動で保存</button>

<div class="container" id="taskContainer">
  <!-- タスク管理パネル -->
  <div class="controls">
    <input type="text" id="categoryInput" placeholder="カテゴリー">
    <input type="text" id="taskNameInput" placeholder="タスク名">
    <button id="addTaskBtn">＋タスク追加</button>
    <button id="stopAllBtn">STOP ALL</button>
    <button id="resetAllBtn">RESET ALL</button>
    <button id="exportCsvBtn">CSVエクスポート</button>
  </div>
  <datalist id="categorySuggestions"></datalist>
  <div id="categoriesContainer"></div>
</div>

<!-- スナップショットパネル -->
<div class="snapshot-panel">
  <h2>スナップショット管理</h2>
  <div class="snapshot-controls">
    <input type="date" id="snapshotDateInput">
    <button id="takeSnapshotBtn">この日付でスナップショット取得</button>
  </div>
  <div id="snapshotList" class="snapshot-list"></div>
</div>

<script>
/*
  データ構造:
    mainData:
      tasks, collapsedCategories, knownCategories, categoryOrder, categoryColors : 連続状態
      snapshots : 配列。各スナップショットは { id, label, createdAt, snapshotDate, data }
        data: { tasks, collapsedCategories, knownCategories, categoryOrder, categoryColors }
*/
const STORAGE_KEY = "singleStopwatchPlusSnapshots_v2";
let mainData = {
  tasks: [],
  collapsedCategories: {},
  knownCategories: [],
  categoryOrder: [],
  categoryColors: {},
  snapshots: []
};

let tasks = mainData.tasks;
let collapsedCategories = mainData.collapsedCategories;
let knownCategories = mainData.knownCategories;
let categoryOrder = mainData.categoryOrder;
let categoryColors = mainData.categoryColors;
let snapshots = mainData.snapshots;
let loadedSnapshotDate = "";

const PRESET_COLORS = [
  "#F94144","#F3722C","#F8961E","#F9844A","#F9C74F",
  "#90BE6D","#43AA8B","#4D908E","#577590","#277DA1",
  "#64C3EE","#6367A9","#B986C8","#F48FB1","#FFB5E8",
  "#FFDAC1","#B5EAD7","#C7CEEA","#FF9CEE","#F6B7C6"
];

/* DOM要素取得 */
const manualSaveBtn       = document.getElementById('manualSaveBtn');
const categoryInput       = document.getElementById('categoryInput');
const taskNameInput       = document.getElementById('taskNameInput');
const addTaskBtn          = document.getElementById('addTaskBtn');
const stopAllBtn          = document.getElementById('stopAllBtn');
const resetAllBtn         = document.getElementById('resetAllBtn');
const exportCsvBtn        = document.getElementById('exportCsvBtn');
const categoriesContainer = document.getElementById('categoriesContainer');
const categorySuggestions = document.getElementById('categorySuggestions');

const snapshotDateInput   = document.getElementById('snapshotDateInput');
const takeSnapshotBtn     = document.getElementById('takeSnapshotBtn');
const snapshotListDiv     = document.getElementById('snapshotList');

let globalTimerId = null;

/* localStorage 関連 */
function loadFromLocalStorage(){
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if(saved){
      mainData = JSON.parse(saved);
      tasks = mainData.tasks;
      collapsedCategories = mainData.collapsedCategories;
      knownCategories = mainData.knownCategories;
      categoryOrder = mainData.categoryOrder;
      categoryColors = mainData.categoryColors;
      snapshots = mainData.snapshots;
    }
  } catch(e){
    console.warn("localStorage読み込み失敗:", e);
  }
}
function saveToLocalStorage(){
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(mainData));
    console.log("mainDataをlocalStorageに保存しました");
  } catch(e){
    console.warn("localStorage保存失敗:", e);
  }
}

/* カテゴリ管理 */
function addKnownCategory(cat){
  if(cat && !knownCategories.includes(cat)){
    knownCategories.push(cat);
  }
}
function getOrderedCategories(){
  const usedCats = [...new Set(tasks.map(t => t.category))];
  let ordered = categoryOrder.filter(c => usedCats.includes(c));
  usedCats.forEach(c => {
    if(!ordered.includes(c)){
      ordered.push(c);
    }
  });
  categoryOrder = ordered;
  return ordered;
}
function renameCategory(oldName, newName){
  if(!oldName || !newName) return;
  if(oldName === newName) return;
  tasks.forEach(t=>{
    if(t.category === oldName){
      t.category = newName;
    }
  });
  if(knownCategories.includes(oldName)){
    knownCategories = knownCategories.filter(c => c !== oldName);
    knownCategories.push(newName);
  }
  const idx = categoryOrder.indexOf(oldName);
  if(idx >= 0){ categoryOrder[idx] = newName; }
  if(categoryColors[oldName]){
    categoryColors[newName] = categoryColors[oldName];
    delete categoryColors[oldName];
  }
  if(collapsedCategories.hasOwnProperty(oldName)){
    collapsedCategories[newName] = collapsedCategories[oldName];
    delete collapsedCategories[oldName];
  }
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}
function reorderCategories(fromIndex, toIndex){
  if(fromIndex === toIndex)return;
  const moved = categoryOrder.splice(fromIndex, 1)[0];
  categoryOrder.splice(toIndex, 0, moved);
  renderAll();
  saveToLocalStorage();
}
function toggleCategoryCollapse(cat){
  collapsedCategories[cat] = !collapsedCategories[cat];
  renderAll();
  saveToLocalStorage();
}
function getCategoryColor(cat){
  return categoryColors[cat] || "#e0e0e0";
}
function setCategoryColor(cat, colVal){
  categoryColors[cat] = colVal;
  renderAll();
  saveToLocalStorage();
}
function cleanupCategories(){
  const usedCats = new Set(tasks.map(t => t.category));
  knownCategories = knownCategories.filter(c => usedCats.has(c) && c !== '');
  categoryOrder = categoryOrder.filter(c => usedCats.has(c));
  for(const c in categoryColors){
    if(!usedCats.has(c)){
      delete categoryColors[c];
    }
  }
  for(const c in collapsedCategories){
    if(!usedCats.has(c)){
      delete collapsedCategories[c];
    }
  }
  for(const c of usedCats){
    if(c !== '' && !categoryColors[c]){
      autoAssignColor(c);
    }
  }
}
function autoAssignColor(cat){
  if(categoryColors[cat]) return;
  const used = new Set(Object.values(categoryColors));
  for(const col of PRESET_COLORS){
    if(!used.has(col)){
      categoryColors[cat] = col;
      return;
    }
  }
  categoryColors[cat] = PRESET_COLORS[0] || "#e0e0e0";
}

/* タスク操作 */
function addTask(cat, name){
  const c = cat || '';
  const nm = name || '';
  if(!collapsedCategories.hasOwnProperty(c)){
    collapsedCategories[c] = false;
  }
  addKnownCategory(c);
  if(!categoryOrder.includes(c)){
    categoryOrder.push(c);
  }
  tasks.push({
    id: Date.now(),
    category: c,
    name: nm,
    startTime: 0,
    elapsedTime: 0,
    running: false,
    subtasks: [],
    subtasksCollapsed: false  // サブタスク領域は初期は展開状態
  });
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}
function deleteTask(id){
  tasks = tasks.filter(t => t.id !== id);
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}
function toggleTask(id){
  const task = tasks.find(t => t.id === id);
  if(!task)return;
  // サブタスクがある場合、親タスクのタイマーは無効化（タイマー表示はサブタスクの合計時間にする）
  if(task.subtasks && task.subtasks.length > 0){
    // 親タスクのタイマー操作を無視
    return;
  }
  if(!task.running){
    task.running = true;
    task.startTime = Date.now();
    startGlobalTimer();
  } else {
    const now = Date.now();
    task.elapsedTime += (now - task.startTime);
    task.running = false;
  }
  renderAll();
  saveToLocalStorage();
}
function resetTask(id){
  const task = tasks.find(t => t.id === id);
  if(!task)return;
  task.running = false;
  task.elapsedTime = 0;
  task.startTime = 0;
  if(task.subtasks){
    task.subtasks.forEach(st => {
      st.running = false;
      st.elapsedTime = 0;
      st.startTime = 0;
    });
  }
  renderAll();
  saveToLocalStorage();
}
function reorderTasksInCategory(cat, fromIndex, toIndex){
  if(fromIndex === toIndex)return;
  let catTasks = tasks.filter(t => t.category === cat);
  if(fromIndex < 0 || fromIndex >= catTasks.length) return;
  if(toIndex < 0 || toIndex >= catTasks.length) return;
  const [moved] = catTasks.splice(fromIndex, 1);
  catTasks.splice(toIndex, 0, moved);
  let newTasks = [];
  let catCounter = 0;
  tasks.forEach(t=>{
    if(t.category === cat){
      newTasks.push(catTasks[catCounter]);
      catCounter++;
    } else {
      newTasks.push(t);
    }
  });
  tasks = newTasks;
  renderAll();
  saveToLocalStorage();
}
function moveTaskToCategory(taskId, newCat, newIndex=null){
  const task = tasks.find(t => t.id === taskId);
  if(!task)return;
  const oldCat = task.category;
  let oldCatTasks = tasks.filter(t => t.category === oldCat && t.id !== taskId);
  let newCatTasks = tasks.filter(t => t.category === newCat);
  task.category = newCat;
  if(!collapsedCategories.hasOwnProperty(newCat)){
    collapsedCategories[newCat] = false;
  }
  addKnownCategory(newCat);
  if(!categoryOrder.includes(newCat)){
    categoryOrder.push(newCat);
  }
  if(newIndex === null || newIndex < 0 || newIndex > newCatTasks.length){
    newCatTasks.push(task);
  } else {
    newCatTasks.splice(newIndex, 0, task);
  }
  let others = tasks.filter(t => t.category !== oldCat && t.category !== newCat);
  others = [...others, ...oldCatTasks];
  others = others.filter(t => t.category !== newCat);
  tasks = [...others, ...newCatTasks];
  cleanupCategories();
  renderAll();
  saveToLocalStorage();
}

/* サブタスク操作 */
function addSubtask(taskId, subtaskName) {
  const task = tasks.find(t => t.id === taskId);
  if(!task) return;
  if(!task.subtasks) task.subtasks = [];
  task.subtasks.push({
    id: Date.now(),
    name: subtaskName,
    startTime: 0,
    elapsedTime: 0,
    running: false
  });
  renderAll();
  saveToLocalStorage();
}
function toggleSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  const subtask = task.subtasks.find(s => s.id === subtaskId);
  if(!subtask) return;
  if(!subtask.running){
    subtask.running = true;
    subtask.startTime = Date.now();
    startGlobalTimer();
  } else {
    const now = Date.now();
    subtask.elapsedTime += (now - subtask.startTime);
    subtask.running = false;
  }
  renderAll();
  saveToLocalStorage();
}
function resetSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  const subtask = task.subtasks.find(s => s.id === subtaskId);
  if(!subtask) return;
  subtask.running = false;
  subtask.elapsedTime = 0;
  subtask.startTime = 0;
  renderAll();
  saveToLocalStorage();
}
function deleteSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  task.subtasks = task.subtasks.filter(s => s.id !== subtaskId);
  renderAll();
  saveToLocalStorage();
}
  
/* サブタスク領域の折りたたみ toggle */
function toggleSubtasksCollapse(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task) return;
  task.subtasksCollapsed = !task.subtasksCollapsed;
  renderAll();
  saveToLocalStorage();
}
  
/* サブタスクレンダリング */
function renderSubtask(task, subtask, subIndex) {
  const subDiv = document.createElement("div");
  subDiv.className = "subtask-card";
  const subHandle = document.createElement("div");
  subHandle.className = "subtask-handle";
  subHandle.textContent = "≡";
  subDiv.appendChild(subHandle);
  const subNameInput = document.createElement("input");
  subNameInput.type = "text";
  subNameInput.className = "subtask-name";
  subNameInput.value = subtask.name;
  subNameInput.addEventListener("change", ()=>{
    subtask.name = subNameInput.value;
    saveToLocalStorage();
  });
  subDiv.appendChild(subNameInput);
  const subTimeDiv = document.createElement("div");
  subTimeDiv.className = "subtask-time";
  if(subtask.running){
    const now = Date.now();
    subTimeDiv.textContent = formatTime(subtask.elapsedTime + (now - subtask.startTime));
  } else {
    subTimeDiv.textContent = formatTime(subtask.elapsedTime);
  }
  subDiv.appendChild(subTimeDiv);
  const subBtnGroup = document.createElement("div");
  subBtnGroup.className = "subtask-btn-group";
  const subStartStopBtn = document.createElement("button");
  if(subtask.running){
    subStartStopBtn.className = "subtask-stop-btn";
    subStartStopBtn.textContent = "STOP";
  } else {
    subStartStopBtn.className = "subtask-start-btn";
    subStartStopBtn.textContent = "START";
  }
  subStartStopBtn.addEventListener("click", ()=>{
    toggleSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subStartStopBtn);
  const subResetBtn = document.createElement("button");
  subResetBtn.className = "subtask-reset-btn";
  subResetBtn.textContent = "RESET";
  subResetBtn.addEventListener("click", ()=>{
    resetSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subResetBtn);
  const subDeleteBtn = document.createElement("button");
  subDeleteBtn.className = "subtask-delete-btn";
  subDeleteBtn.textContent = "削除";
  subDeleteBtn.addEventListener("click", ()=>{
    deleteSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subDeleteBtn);
  subDiv.appendChild(subBtnGroup);
  return subDiv;
}
  
/* 時間表示 */
function formatTime(msTotal){
  const ms = msTotal % 1000;
  const sec = Math.floor(msTotal/1000) % 60;
  const min = Math.floor(msTotal/60000);
  const mm = String(min).padStart(2, "0");
  const ss = String(sec).padStart(2, "0");
  const mss = String(ms).padStart(3, "0");
  return `${mm}:${ss}.${mss}`;
}
function getCategoryTotalTime(cat){
  let sum = 0;
  const now = Date.now();
  tasks.forEach(t=>{
    if(t.category === cat){
      let base = t.elapsedTime;
      if(t.running){ base += (now - t.startTime); }
      // サブタスクがある場合、親タスクの時間はサブタスク合計で上書き
      if(t.subtasks && t.subtasks.length > 0){
        let subTotal = 0;
        t.subtasks.forEach(st=>{
          let stBase = st.elapsedTime;
          if(st.running){ stBase += (now - st.startTime); }
          subTotal += stBase;
        });
        base = subTotal;
      }
      sum += base;
    }
  });
  return sum;
}
  
/* 全STOP / RESET ALL */
function stopAllTasks(){
  const now = Date.now();
  tasks.forEach(t=>{
    if(t.running){
      t.elapsedTime += (now - t.startTime);
      t.running = false;
    }
    if(t.subtasks){
      t.subtasks.forEach(st=>{
        if(st.running){
          st.elapsedTime += (now - st.startTime);
          st.running = false;
        }
      });
    }
  });
  renderAll();
  saveToLocalStorage();
}
function resetAllTasks(){
  tasks.forEach(t=>{
    t.running = false;
    t.elapsedTime = 0;
    t.startTime = 0;
    if(t.subtasks){
      t.subtasks.forEach(st=>{
        st.running = false;
        st.elapsedTime = 0;
        st.startTime = 0;
      });
    }
  });
  renderAll();
  saveToLocalStorage();
}
  
/* メイン描画 */
function renderAll(){
  categoriesContainer.innerHTML = "";
  cleanupCategories();
  const categories = getOrderedCategories();
  categories.forEach((cat, catIndex) => {
    const catCard = document.createElement('div');
    catCard.className = 'category-card';
    catCard.draggable = true;
    catCard.addEventListener('dragstart', e=>{
      e.dataTransfer.setData('type','category');
      e.dataTransfer.setData('fromIndex', String(catIndex));
    });
    catCard.addEventListener('dragover', e=>{
      e.preventDefault();
      const dragType = e.dataTransfer.getData('type');
      if(dragType==='category' || dragType==='task'){
        catCard.classList.add('drag-over');
      }
    });
    catCard.addEventListener('dragleave', ()=>{
      catCard.classList.remove('drag-over');
    });
    catCard.addEventListener('drop', e=>{
      e.preventDefault();
      catCard.classList.remove('drag-over');
      const dragType = e.dataTransfer.getData('type');
      if(dragType==='category'){
        const fromIndex = parseInt(e.dataTransfer.getData('fromIndex'),10);
        reorderCategories(fromIndex, catIndex);
      } else if(dragType==='task'){
        const tid = parseInt(e.dataTransfer.getData('taskId'),10);
        moveTaskToCategory(tid, cat, null);
      }
    });
  
    const catHeader = document.createElement('div');
    catHeader.className = 'category-header';
    catHeader.style.backgroundColor = getCategoryColor(cat);
  
    const handleDiv = document.createElement('div');
    handleDiv.className = 'cat-handle';
    handleDiv.textContent = '≡';
    catHeader.appendChild(handleDiv);
  
    // 左側: 折りたたみボタン + カテゴリ名 (ダブルクリック編集) + 合計時間
    const catInfo = document.createElement('div');
    catInfo.className = 'cat-info';
  
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'cat-toggle-btn';
    toggleBtn.textContent = collapsedCategories[cat] ? '▶' : '▼';
    toggleBtn.addEventListener('click', ()=> { toggleCategoryCollapse(cat); });
    catInfo.appendChild(toggleBtn);
  
    const catNameSpan = document.createElement('span');
    catNameSpan.className = 'cat-name';
    catNameSpan.textContent = cat || '(未設定)';
    catNameSpan.addEventListener('dblclick', ()=>{
      const oldVal = cat;
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'cat-name-edit';
      input.value = cat || '(未設定)';
      catInfo.replaceChild(input, catNameSpan);
      input.focus();
      input.select();
      function confirmRename(newVal){
        const finalVal = newVal.trim() || '(未設定)';
        catNameSpan.textContent = finalVal;
        catInfo.replaceChild(catNameSpan, input);
        if(finalVal==='(未設定)'){
          renameCategory(oldVal, '');
        } else {
          renameCategory(oldVal, finalVal);
        }
      }
      input.addEventListener('blur', ()=>{ confirmRename(input.value); });
      input.addEventListener('keydown', (e)=>{
        if(e.key==='Enter'){
          confirmRename(input.value);
        } else if(e.key==='Escape'){
          catInfo.replaceChild(catNameSpan, input);
        }
      });
    });
    catInfo.appendChild(catNameSpan);
  
    const sumMs = getCategoryTotalTime(cat);
    const sumSpan = document.createElement('span');
    sumSpan.className = 'cat-sum-time';
    sumSpan.textContent = `合計時間: ${formatTime(sumMs)}`;
    catInfo.appendChild(sumSpan);
  
    catHeader.appendChild(catInfo);
  
    // 右側: カラー選択 + ＋ボタン
    const catRight = document.createElement('div');
    catRight.className = 'cat-right';
  
    const paletteWrap = document.createElement('div');
    paletteWrap.className = 'color-palette';
    paletteWrap.style.position = 'relative';
  
    const colorBtn = document.createElement('button');
    colorBtn.className = 'color-palette-btn';
    colorBtn.textContent = 'Color';
    const preview = document.createElement('div');
    preview.className = 'color-preview';
    preview.style.backgroundColor = getCategoryColor(cat);
    colorBtn.appendChild(preview);
    const popup = document.createElement('div');
    popup.className = 'color-palette-popup';
    PRESET_COLORS.forEach(col=>{
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = col;
      swatch.addEventListener('click', ()=>{
        setCategoryColor(cat, col);
        preview.style.backgroundColor = col;
        paletteWrap.classList.remove('open');
      });
      popup.appendChild(swatch);
    });
    paletteWrap.appendChild(colorBtn);
    paletteWrap.appendChild(popup);
    colorBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      paletteWrap.classList.toggle('open');
    });
    document.addEventListener('click', (evt)=>{
      if(!paletteWrap.contains(evt.target)){
        paletteWrap.classList.remove('open');
      }
    });
    catRight.appendChild(paletteWrap);
  
    const plusBtn = document.createElement('button');
    plusBtn.className = 'cat-add-btn';
    plusBtn.textContent = '+';
    plusBtn.addEventListener('click', ()=>{ addTask(cat, 'New Task'); });
    catRight.appendChild(plusBtn);
  
    catHeader.appendChild(catRight);
    catCard.appendChild(catHeader);
  
    // タスクリスト
    if(!collapsedCategories[cat]){
      const taskList = document.createElement('div');
      taskList.className = 'task-list';
      const catTasks = tasks.filter(t => t.category === cat);
      catTasks.forEach((task, indexInCat) => {
        const taskDiv = document.createElement('div');
        taskDiv.className = 'task-card';
        taskDiv.draggable = true;
        taskDiv.style.backgroundColor = getCategoryColor(cat);
        taskDiv.addEventListener('dragstart', e=>{
          e.dataTransfer.setData('type','task');
          e.dataTransfer.setData('taskId', String(task.id));
          e.dataTransfer.setData('fromCategory', cat);
          e.dataTransfer.setData('fromIndex', String(indexInCat));
        });
        taskDiv.addEventListener('dragover', e=>{
          e.preventDefault();
          if(e.dataTransfer.getData('type')==='task'){
            taskDiv.classList.add('drag-over');
          }
        });
        taskDiv.addEventListener('dragleave', ()=>{
          taskDiv.classList.remove('drag-over');
        });
        taskDiv.addEventListener('drop', e=>{
          e.preventDefault();
          taskDiv.classList.remove('drag-over');
          if(e.dataTransfer.getData('type')==='task'){
            const fromCat = e.dataTransfer.getData('fromCategory');
            const fromIndex = parseInt(e.dataTransfer.getData('fromIndex'),10);
            const tid = parseInt(e.dataTransfer.getData('taskId'),10);
            if(fromCat === cat){
              reorderTasksInCategory(cat, fromIndex, indexInCat);
            } else {
              moveTaskToCategory(tid, cat, indexInCat);
            }
          }
        });
  
        const taskHandle = document.createElement('div');
        taskHandle.className = 'task-handle';
        taskHandle.textContent = '≡';
        taskDiv.appendChild(taskHandle);
  
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'task-name';
        nameInput.value = task.name;
        nameInput.addEventListener('change', ()=>{
          task.name = nameInput.value;
          saveToLocalStorage();
        });
        taskDiv.appendChild(nameInput);
  
        const timeDiv = document.createElement('div');
        timeDiv.className = 'time-display';
        // サブタスクがある場合、親タスクのタイマーは表示せず、サブタスク合計を表示
        if(task.subtasks && task.subtasks.length > 0){
          let subTotal = 0;
          const now = Date.now();
          task.subtasks.forEach(st=>{
            let stTime = st.elapsedTime;
            if(st.running){ stTime += (now - st.startTime); }
            subTotal += stTime;
          });
          timeDiv.textContent = formatTime(subTotal);
        } else {
          if(task.running){
            const now = Date.now();
            timeDiv.textContent = formatTime(task.elapsedTime + (now - task.startTime));
          } else {
            timeDiv.textContent = formatTime(task.elapsedTime);
          }
        }
        taskDiv.appendChild(timeDiv);
  
        // ボタン群
        const btnGroup = document.createElement('div');
        btnGroup.className = 'btn-group';
        // 親タスク：サブタスクがある場合、タイマー操作ボタンは非表示
        if(!(task.subtasks && task.subtasks.length > 0)){
          const startStopBtn = document.createElement('button');
          if(task.running){
            startStopBtn.className = 'stop-btn';
            startStopBtn.textContent = 'STOP';
          } else {
            startStopBtn.className = 'start-btn';
            startStopBtn.textContent = 'START';
          }
          startStopBtn.addEventListener('click', ()=>{ toggleTask(task.id); });
          btnGroup.appendChild(startStopBtn);
        }
        const resetBtn = document.createElement('button');
        resetBtn.className = 'reset-btn';
        resetBtn.textContent = 'RESET';
        resetBtn.addEventListener('click', ()=>{ resetTask(task.id); });
        btnGroup.appendChild(resetBtn);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = '削除';
        deleteBtn.addEventListener('click', ()=>{ deleteTask(task.id); });
        btnGroup.appendChild(deleteBtn);
        taskDiv.appendChild(btnGroup);
  
        /* ----- サブタスク領域 ----- */
        // サブタスク折りたたみボタン
        const subToggleBtn = document.createElement("button");
        subToggleBtn.className = "subtask-toggle-btn";
        subToggleBtn.textContent = task.subtasksCollapsed ? "▶ サブタスク" : "▼ サブタスク";
        subToggleBtn.addEventListener("click", ()=>{
          toggleSubtasksCollapse(task.id);
        });
        taskDiv.appendChild(subToggleBtn);
  
        // サブタスクリスト（親タスク内に格納、はみ出さないようにする）
        if(!task.subtasksCollapsed){
          const subtaskListDiv = document.createElement("div");
          subtaskListDiv.className = "subtask-list";
          // Ensure subtask list does not exceed task-card width
          subtaskListDiv.style.width = "100%";
          subtaskListDiv.style.overflowX = "auto";
          if(task.subtasks && task.subtasks.length > 0){
            task.subtasks.forEach((subtask, subIndex)=>{
              const subDiv = renderSubtask(task, subtask, subIndex);
              subtaskListDiv.appendChild(subDiv);
            });
          }
          // サブタスク追加ボタン
          const addSubtaskBtn = document.createElement("button");
          addSubtaskBtn.className = "subtask-add-btn";
          addSubtaskBtn.textContent = "＋サブタスク追加";
          addSubtaskBtn.addEventListener("click", ()=>{
            const subName = prompt("サブタスク名を入力してください", "New Subtask");
            if(subName !== null){
              addSubtask(task.id, subName.trim() || "New Subtask");
            }
          });
          subtaskListDiv.appendChild(addSubtaskBtn);
          taskDiv.appendChild(subtaskListDiv);
        }
        /* ----- /サブタスク領域 ----- */
  
        taskList.appendChild(taskDiv);
      });
      catCard.appendChild(taskList);
    }
    categoriesContainer.appendChild(catCard);
  });
  updateCategorySuggestions();
  saveCurrentState();
  saveToLocalStorage();
}
  
/* サジェスト更新 */
function updateCategorySuggestions(){
  categorySuggestions.innerHTML = "";
  knownCategories.forEach(c=>{
    const opt = document.createElement('option');
    opt.value = c;
    categorySuggestions.appendChild(opt);
  });
}
  
/* タイマー (60fps 更新) */
function renderRunningState(){
  let anyRunning = false;
  const categories = getOrderedCategories();
  categories.forEach((cat, catIndex) => {
    const catTasks = tasks.filter(t => t.category === cat);
    let sumMs = 0;
    const now = Date.now();
    catTasks.forEach(task => {
      let base = task.elapsedTime;
      if(task.running){
        base += (now - task.startTime);
        anyRunning = true;
      }
      // サブタスクがある場合は親タスクの時間はサブタスク合計に依存
      if(task.subtasks && task.subtasks.length > 0){
        let subTotal = 0;
        task.subtasks.forEach(st=>{
          let stBase = st.elapsedTime;
          if(st.running){
            stBase += (now - st.startTime);
            anyRunning = true;
          }
          subTotal += stBase;
        });
        base = subTotal;
      }
      sumMs += base;
    });
    const catCard = categoriesContainer.children[catIndex];
    if(catCard){
      const catInfo = catCard.querySelector('.cat-info');
      if(catInfo){
        const sumSpan = catInfo.querySelector('.cat-sum-time');
        if(sumSpan){
          sumSpan.textContent = `合計時間: ${formatTime(sumMs)}`;
        }
      }
    }
    if(!collapsedCategories[cat]){
      const taskList = catCard.querySelector('.task-list');
      if(taskList){
        const taskCards = taskList.querySelectorAll('.task-card');
        taskCards.forEach((card, i) => {
          const task = catTasks[i];
          if(!task)return;
          const timeDiv = card.querySelector('.time-display');
          if(task.subtasks && task.subtasks.length > 0){
            // 親タスクのタイマー表示はサブタスク合計時間
            let subTotal = 0;
            task.subtasks.forEach(st=>{
              let stBase = st.elapsedTime;
              if(st.running){ stBase += (Date.now() - st.startTime); }
              subTotal += stBase;
            });
            timeDiv.textContent = formatTime(subTotal);
          } else {
            const btnGroup = card.querySelector('.btn-group');
            const startStopBtn = btnGroup ? btnGroup.children[0] : null;
            if(task.running){
              const now = Date.now();
              timeDiv.textContent = formatTime(task.elapsedTime + (now - task.startTime));
              if(startStopBtn){
                startStopBtn.className = 'stop-btn';
                startStopBtn.textContent = 'STOP';
              }
            } else {
              timeDiv.textContent = formatTime(task.elapsedTime);
              if(startStopBtn){
                startStopBtn.className = 'start-btn';
                startStopBtn.textContent = 'START';
              }
            }
          }
          // サブタスク更新
          if(task.subtasks && task.subtasks.length > 0){
            const subtaskDivs = card.querySelectorAll('.subtask-card');
            task.subtasks.forEach((st, subIndex) => {
              const subDiv = subtaskDivs[subIndex];
              if(subDiv){
                const subTimeDiv = subDiv.querySelector('.subtask-time');
                if(st.running){
                  subTimeDiv.textContent = formatTime(st.elapsedTime + (Date.now() - st.startTime));
                } else {
                  subTimeDiv.textContent = formatTime(st.elapsedTime);
                }
              }
            });
          }
        });
      }
    }
  });
  if(!anyRunning){
    clearInterval(globalTimerId);
    globalTimerId = null;
  }
}
function startGlobalTimer(){
  if(globalTimerId)return;
  globalTimerId = setInterval(()=>{ renderRunningState(); },16);
}
  
/* 現行状態の保存 */
function saveCurrentState(){
  mainData.tasks = tasks;
  mainData.collapsedCategories = collapsedCategories;
  mainData.knownCategories = knownCategories;
  mainData.categoryOrder = categoryOrder;
  mainData.categoryColors = categoryColors;
  saveToLocalStorage();
}
  
/* CSVエクスポート (UTF-8 BOM付き) */
function exportCsv(){
  const dateStr = loadedSnapshotDate || new Date().toLocaleDateString();
  const lines = [];
  lines.push("Category,Date,TaskName,Time,CategoryTotal");
  const catMap = new Map();
  tasks.forEach(t=>{
    if(!catMap.has(t.category)){
      catMap.set(t.category, getCategoryTotalTime(t.category));
    }
  });
  tasks.forEach(t=>{
    let base = t.elapsedTime;
    if(t.running){
      base += (Date.now() - t.startTime);
    }
    const timeStr = formatTime(base);
    const catTotalStr = formatTime(catMap.get(t.category) || 0);
    const row = [
      `"${t.category}"`,
      `"${dateStr}"`,
      `"${t.name}"`,
      `"${timeStr}"`,
      `"${catTotalStr}"`
    ].join(",");
    lines.push(row);
  });
  const csvContent = lines.join("\r\n");
  const bom = "\uFEFF";
  const blob = new Blob([bom + csvContent], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `Stopwatch_${dateStr}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
  
/* ================================
   スナップショット機能
   - takeSnapshot(): 指定した日付で現在の状態を保存
   - loadSnapshot(): 指定スナップショットの状態を復元
   - renderSnapshotList(): snapshotDateInput の値に一致するスナップショットのみ表示
================================ */
function takeSnapshot(){
  const dateStr = snapshotDateInput.value;
  if(!dateStr){
    alert("スナップショットの日付を指定してください");
    return;
  }
  const now = new Date();
  const label = `Snapshot ${now.toLocaleString()} (${dateStr})`;
  const snap = {
    id: Date.now(),
    label,
    createdAt: now.getTime(),
    snapshotDate: dateStr,
    data: {
      tasks: structuredClone(tasks),
      collapsedCategories: structuredClone(collapsedCategories),
      knownCategories: structuredClone(knownCategories),
      categoryOrder: structuredClone(categoryOrder),
      categoryColors: structuredClone(categoryColors)
    }
  };
  snapshots.push(snap);
  saveToLocalStorage();
  alert(`スナップショットを保存しました: ${label}`);
  renderSnapshotList();
}
function loadSnapshot(snapId){
  const snap = snapshots.find(s => s.id === snapId);
  if(!snap){
    alert("該当スナップショットが見つかりません");
    return;
  }
  tasks = snap.data.tasks || [];
  collapsedCategories = snap.data.collapsedCategories || {};
  knownCategories = snap.data.knownCategories || [];
  categoryOrder = snap.data.categoryOrder || [];
  categoryColors = snap.data.categoryColors || {};
  loadedSnapshotDate = snap.snapshotDate || "";
  alert(`スナップショット「${snap.label}」を読み込みました`);
  renderAll();
  if(tasks.some(t => t.running)){
    startGlobalTimer();
  }
}
function renderSnapshotList(){
  snapshotListDiv.innerHTML = "";
  const selectedDate = snapshotDateInput.value;
  let filtered = [];
  if(selectedDate){
    filtered = snapshots.filter(snap => snap.snapshotDate === selectedDate);
  } else {
    filtered = snapshots;
  }
  if(filtered.length === 0){
    snapshotListDiv.textContent = "(該当するスナップショットがありません)";
    return;
  }
  filtered.forEach(snap => {
    const btn = document.createElement("button");
    btn.textContent = snap.label;
    btn.addEventListener("click", ()=>{
      loadSnapshot(snap.id);
      renderSnapshotList();
    });
    snapshotListDiv.appendChild(btn);
  });
}
  
/* タイマー (60fps 更新) */
function renderRunningState(){
  let anyRunning = false;
  const categories = getOrderedCategories();
  categories.forEach((cat, catIndex) => {
    const catTasks = tasks.filter(t => t.category === cat);
    let sumMs = 0;
    const now = Date.now();
    catTasks.forEach(task => {
      let base = task.elapsedTime;
      if(task.running){
        base += (now - task.startTime);
        anyRunning = true;
      }
      // 親タスクにサブタスクがある場合、親のタイマーはサブタスク合計
      if(task.subtasks && task.subtasks.length > 0){
        let subTotal = 0;
        task.subtasks.forEach(st=>{
          let stBase = st.elapsedTime;
          if(st.running){
            stBase += (now - st.startTime);
            anyRunning = true;
          }
          subTotal += stBase;
        });
        base = subTotal;
      }
      sumMs += base;
    });
    const catCard = categoriesContainer.children[catIndex];
    if(catCard){
      const catInfo = catCard.querySelector('.cat-info');
      if(catInfo){
        const sumSpan = catInfo.querySelector('.cat-sum-time');
        if(sumSpan){
          sumSpan.textContent = `合計時間: ${formatTime(sumMs)}`;
        }
      }
    }
    if(!collapsedCategories[cat]){
      const taskList = catCard.querySelector('.task-list');
      if(taskList){
        const taskCards = taskList.querySelectorAll('.task-card');
        taskCards.forEach((card, i) => {
          const task = catTasks[i];
          if(!task)return;
          const timeDiv = card.querySelector('.time-display');
          if(task.subtasks && task.subtasks.length > 0){
            let subTotal = 0;
            task.subtasks.forEach(st=>{
              let stBase = st.elapsedTime;
              if(st.running){ stBase += (Date.now() - st.startTime); }
              subTotal += stBase;
            });
            timeDiv.textContent = formatTime(subTotal);
          } else {
            const btnGroup = card.querySelector('.btn-group');
            const startStopBtn = btnGroup ? btnGroup.children[0] : null;
            if(task.running){
              const now = Date.now();
              timeDiv.textContent = formatTime(task.elapsedTime + (now - task.startTime));
              if(startStopBtn){
                startStopBtn.className = 'stop-btn';
                startStopBtn.textContent = 'STOP';
              }
            } else {
              timeDiv.textContent = formatTime(task.elapsedTime);
              if(startStopBtn){
                startStopBtn.className = 'start-btn';
                startStopBtn.textContent = 'START';
              }
            }
          }
          // サブタスク更新
          if(task.subtasks && task.subtasks.length > 0){
            const subtaskDivs = card.querySelectorAll('.subtask-card');
            task.subtasks.forEach((st, subIndex) => {
              const subDiv = subtaskDivs[subIndex];
              if(subDiv){
                const subTimeDiv = subDiv.querySelector('.subtask-time');
                if(st.running){
                  subTimeDiv.textContent = formatTime(st.elapsedTime + (Date.now() - st.startTime));
                } else {
                  subTimeDiv.textContent = formatTime(st.elapsedTime);
                }
              }
            });
          }
        });
      }
    }
  });
  if(!anyRunning){
    clearInterval(globalTimerId);
    globalTimerId = null;
  }
}
function startGlobalTimer(){
  if(globalTimerId)return;
  globalTimerId = setInterval(()=>{ renderRunningState(); }, 16);
}
  
/* 現行状態の保存 */
function saveCurrentState(){
  mainData.tasks = tasks;
  mainData.collapsedCategories = collapsedCategories;
  mainData.knownCategories = knownCategories;
  mainData.categoryOrder = categoryOrder;
  mainData.categoryColors = categoryColors;
  saveToLocalStorage();
}
  
/* CSVエクスポート (UTF-8 BOM付き) */
function exportCsv(){
  const dateStr = loadedSnapshotDate || new Date().toLocaleDateString();
  const lines = [];
  lines.push("Category,Date,TaskName,Time,CategoryTotal");
  const catMap = new Map();
  tasks.forEach(t=>{
    if(!catMap.has(t.category)){
      catMap.set(t.category, getCategoryTotalTime(t.category));
    }
  });
  tasks.forEach(t=>{
    let base = t.elapsedTime;
    if(t.running){
      base += (Date.now() - t.startTime);
    }
    const timeStr = formatTime(base);
    const catTotalStr = formatTime(catMap.get(t.category) || 0);
    const row = [
      `"${t.category}"`,
      `"${dateStr}"`,
      `"${t.name}"`,
      `"${timeStr}"`,
      `"${catTotalStr}"`
    ].join(",");
    lines.push(row);
  });
  const csvContent = lines.join("\r\n");
  const bom = "\uFEFF";
  const blob = new Blob([bom + csvContent], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `Stopwatch_${dateStr}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
  
/* ================================
   サブタスクのレンダリング
================================ */
function renderSubtask(task, subtask, subIndex) {
  const subDiv = document.createElement("div");
  subDiv.className = "subtask-card";
  const subHandle = document.createElement("div");
  subHandle.className = "subtask-handle";
  subHandle.textContent = "≡";
  subDiv.appendChild(subHandle);
  const subNameInput = document.createElement("input");
  subNameInput.type = "text";
  subNameInput.className = "subtask-name";
  subNameInput.value = subtask.name;
  subNameInput.addEventListener("change", ()=>{
    subtask.name = subNameInput.value;
    saveToLocalStorage();
  });
  subDiv.appendChild(subNameInput);
  const subTimeDiv = document.createElement("div");
  subTimeDiv.className = "subtask-time";
  if(subtask.running){
    const now = Date.now();
    subTimeDiv.textContent = formatTime(subtask.elapsedTime + (now - subtask.startTime));
  } else {
    subTimeDiv.textContent = formatTime(subtask.elapsedTime);
  }
  subDiv.appendChild(subTimeDiv);
  const subBtnGroup = document.createElement("div");
  subBtnGroup.className = "subtask-btn-group";
  const subStartStopBtn = document.createElement("button");
  if(subtask.running){
    subStartStopBtn.className = "subtask-stop-btn";
    subStartStopBtn.textContent = "STOP";
  } else {
    subStartStopBtn.className = "subtask-start-btn";
    subStartStopBtn.textContent = "START";
  }
  subStartStopBtn.addEventListener("click", ()=>{
    toggleSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subStartStopBtn);
  const subResetBtn = document.createElement("button");
  subResetBtn.className = "subtask-reset-btn";
  subResetBtn.textContent = "RESET";
  subResetBtn.addEventListener("click", ()=>{
    resetSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subResetBtn);
  const subDeleteBtn = document.createElement("button");
  subDeleteBtn.className = "subtask-delete-btn";
  subDeleteBtn.textContent = "削除";
  subDeleteBtn.addEventListener("click", ()=>{
    deleteSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subDeleteBtn);
  subDiv.appendChild(subBtnGroup);
  return subDiv;
}
  
/* サブタスク操作 */
function addSubtask(taskId, subtaskName) {
  const task = tasks.find(t => t.id === taskId);
  if(!task) return;
  if(!task.subtasks) task.subtasks = [];
  task.subtasks.push({
    id: Date.now(),
    name: subtaskName,
    startTime: 0,
    elapsedTime: 0,
    running: false
  });
  renderAll();
  saveToLocalStorage();
}
function toggleSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  const subtask = task.subtasks.find(s => s.id === subtaskId);
  if(!subtask) return;
  if(!subtask.running){
    subtask.running = true;
    subtask.startTime = Date.now();
    startGlobalTimer();
  } else {
    const now = Date.now();
    subtask.elapsedTime += (now - subtask.startTime);
    subtask.running = false;
  }
  renderAll();
  saveToLocalStorage();
}
function resetSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  const subtask = task.subtasks.find(s => s.id === subtaskId);
  if(!subtask) return;
  subtask.running = false;
  subtask.elapsedTime = 0;
  subtask.startTime = 0;
  renderAll();
  saveToLocalStorage();
}
function deleteSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  task.subtasks = task.subtasks.filter(s => s.id !== subtaskId);
  renderAll();
  saveToLocalStorage();
}
  
/* サブタスク折りたたみ toggle */
function toggleSubtasksCollapse(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task) return;
  task.subtasksCollapsed = !task.subtasksCollapsed;
  renderAll();
  saveToLocalStorage();
}
  
/* ================================
   スナップショット機能
   - takeSnapshot(): 現在の状態を指定した日付で保存
   - loadSnapshot(): 指定したスナップショットを読み込み現行状態に復元
   - renderSnapshotList(): snapshotDateInput の値に一致するスナップショットのみ表示
================================ */
function takeSnapshot(){
  const dateStr = snapshotDateInput.value;
  if(!dateStr){
    alert("スナップショットの日付を指定してください");
    return;
  }
  const now = new Date();
  const label = `Snapshot ${now.toLocaleString()} (${dateStr})`;
  const snap = {
    id: Date.now(),
    label,
    createdAt: now.getTime(),
    snapshotDate: dateStr,
    data: {
      tasks: structuredClone(tasks),
      collapsedCategories: structuredClone(collapsedCategories),
      knownCategories: structuredClone(knownCategories),
      categoryOrder: structuredClone(categoryOrder),
      categoryColors: structuredClone(categoryColors)
    }
  };
  snapshots.push(snap);
  saveToLocalStorage();
  alert(`スナップショットを保存しました: ${label}`);
  renderSnapshotList();
}
function loadSnapshot(snapId){
  const snap = snapshots.find(s => s.id === snapId);
  if(!snap){
    alert("該当スナップショットが見つかりません");
    return;
  }
  tasks = snap.data.tasks || [];
  collapsedCategories = snap.data.collapsedCategories || {};
  knownCategories = snap.data.knownCategories || [];
  categoryOrder = snap.data.categoryOrder || [];
  categoryColors = snap.data.categoryColors || {};
  loadedSnapshotDate = snap.snapshotDate || "";
  alert(`スナップショット「${snap.label}」を読み込みました`);
  renderAll();
  if(tasks.some(t => t.running)){
    startGlobalTimer();
  }
}
function renderSnapshotList(){
  snapshotListDiv.innerHTML = "";
  const selectedDate = snapshotDateInput.value;
  let filtered = [];
  if(selectedDate){
    filtered = snapshots.filter(snap => snap.snapshotDate === selectedDate);
  } else {
    filtered = snapshots;
  }
  if(filtered.length === 0){
    snapshotListDiv.textContent = "(該当するスナップショットがありません)";
    return;
  }
  filtered.forEach(snap => {
    const btn = document.createElement("button");
    btn.textContent = snap.label;
    btn.addEventListener("click", ()=>{
      loadSnapshot(snap.id);
      renderSnapshotList();
    });
    snapshotListDiv.appendChild(btn);
  });
}
  
/* ================================
   タイマー (60fps 更新)
================================ */
function renderRunningState(){
  let anyRunning = false;
  const categories = getOrderedCategories();
  categories.forEach((cat, catIndex) => {
    const catTasks = tasks.filter(t => t.category === cat);
    let sumMs = 0;
    const now = Date.now();
    catTasks.forEach(task => {
      let base = task.elapsedTime;
      if(task.running){
        base += (now - task.startTime);
        anyRunning = true;
      }
      // 親タスクにサブタスクがある場合、親のタイマーはサブタスク合計
      if(task.subtasks && task.subtasks.length > 0){
        let subTotal = 0;
        task.subtasks.forEach(st=>{
          let stBase = st.elapsedTime;
          if(st.running){
            stBase += (now - st.startTime);
            anyRunning = true;
          }
          subTotal += stBase;
        });
        base = subTotal;
      }
      sumMs += base;
    });
    const catCard = categoriesContainer.children[catIndex];
    if(catCard){
      const catInfo = catCard.querySelector('.cat-info');
      if(catInfo){
        const sumSpan = catInfo.querySelector('.cat-sum-time');
        if(sumSpan){
          sumSpan.textContent = `合計時間: ${formatTime(sumMs)}`;
        }
      }
    }
    if(!collapsedCategories[cat]){
      const taskList = catCard.querySelector('.task-list');
      if(taskList){
        const taskCards = taskList.querySelectorAll('.task-card');
        taskCards.forEach((card, i) => {
          const task = catTasks[i];
          if(!task)return;
          const timeDiv = card.querySelector('.time-display');
          if(task.subtasks && task.subtasks.length > 0){
            let subTotal = 0;
            task.subtasks.forEach(st=>{
              let stBase = st.elapsedTime;
              if(st.running){ stBase += (Date.now() - st.startTime); }
              subTotal += stBase;
            });
            timeDiv.textContent = formatTime(subTotal);
          } else {
            const btnGroup = card.querySelector('.btn-group');
            const startStopBtn = btnGroup ? btnGroup.children[0] : null;
            if(task.running){
              const now = Date.now();
              timeDiv.textContent = formatTime(task.elapsedTime + (now - task.startTime));
              if(startStopBtn){
                startStopBtn.className = 'stop-btn';
                startStopBtn.textContent = 'STOP';
              }
            } else {
              timeDiv.textContent = formatTime(task.elapsedTime);
              if(startStopBtn){
                startStopBtn.className = 'start-btn';
                startStopBtn.textContent = 'START';
              }
            }
          }
          // サブタスク更新
          if(task.subtasks && task.subtasks.length > 0){
            const subtaskDivs = card.querySelectorAll('.subtask-card');
            task.subtasks.forEach((st, subIndex) => {
              const subDiv = subtaskDivs[subIndex];
              if(subDiv){
                const subTimeDiv = subDiv.querySelector('.subtask-time');
                if(st.running){
                  subTimeDiv.textContent = formatTime(st.elapsedTime + (Date.now() - st.startTime));
                } else {
                  subTimeDiv.textContent = formatTime(st.elapsedTime);
                }
              }
            });
          }
        });
      }
    }
  });
  if(!anyRunning){
    clearInterval(globalTimerId);
    globalTimerId = null;
  }
}
function startGlobalTimer(){
  if(globalTimerId)return;
  globalTimerId = setInterval(()=>{ renderRunningState(); }, 16);
}
  
/* 現行状態の保存 */
function saveCurrentState(){
  mainData.tasks = tasks;
  mainData.collapsedCategories = collapsedCategories;
  mainData.knownCategories = knownCategories;
  mainData.categoryOrder = categoryOrder;
  mainData.categoryColors = categoryColors;
  saveToLocalStorage();
}
  
/* CSVエクスポート (UTF-8 BOM付き) */
function exportCsv(){
  const dateStr = loadedSnapshotDate || new Date().toLocaleDateString();
  const lines = [];
  lines.push("Category,Date,TaskName,Time,CategoryTotal");
  const catMap = new Map();
  tasks.forEach(t=>{
    if(!catMap.has(t.category)){
      catMap.set(t.category, getCategoryTotalTime(t.category));
    }
  });
  tasks.forEach(t=>{
    let base = t.elapsedTime;
    if(t.running){
      base += (Date.now() - t.startTime);
    }
    const timeStr = formatTime(base);
    const catTotalStr = formatTime(catMap.get(t.category) || 0);
    const row = [
      `"${t.category}"`,
      `"${dateStr}"`,
      `"${t.name}"`,
      `"${timeStr}"`,
      `"${catTotalStr}"`
    ].join(",");
    lines.push(row);
  });
  const csvContent = lines.join("\r\n");
  const bom = "\uFEFF";
  const blob = new Blob([bom + csvContent], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `Stopwatch_${dateStr}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
  
/* ================================
   サブタスクのレンダリング
================================ */
function renderSubtask(task, subtask, subIndex) {
  const subDiv = document.createElement("div");
  subDiv.className = "subtask-card";
  const subHandle = document.createElement("div");
  subHandle.className = "subtask-handle";
  subHandle.textContent = "≡";
  subDiv.appendChild(subHandle);
  const subNameInput = document.createElement("input");
  subNameInput.type = "text";
  subNameInput.className = "subtask-name";
  subNameInput.value = subtask.name;
  subNameInput.addEventListener("change", ()=>{
    subtask.name = subNameInput.value;
    saveToLocalStorage();
  });
  subDiv.appendChild(subNameInput);
  const subTimeDiv = document.createElement("div");
  subTimeDiv.className = "subtask-time";
  if(subtask.running){
    const now = Date.now();
    subTimeDiv.textContent = formatTime(subtask.elapsedTime + (now - subtask.startTime));
  } else {
    subTimeDiv.textContent = formatTime(subtask.elapsedTime);
  }
  subDiv.appendChild(subTimeDiv);
  const subBtnGroup = document.createElement("div");
  subBtnGroup.className = "subtask-btn-group";
  const subStartStopBtn = document.createElement("button");
  if(subtask.running){
    subStartStopBtn.className = "subtask-stop-btn";
    subStartStopBtn.textContent = "STOP";
  } else {
    subStartStopBtn.className = "subtask-start-btn";
    subStartStopBtn.textContent = "START";
  }
  subStartStopBtn.addEventListener("click", ()=>{
    toggleSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subStartStopBtn);
  const subResetBtn = document.createElement("button");
  subResetBtn.className = "subtask-reset-btn";
  subResetBtn.textContent = "RESET";
  subResetBtn.addEventListener("click", ()=>{
    resetSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subResetBtn);
  const subDeleteBtn = document.createElement("button");
  subDeleteBtn.className = "subtask-delete-btn";
  subDeleteBtn.textContent = "削除";
  subDeleteBtn.addEventListener("click", ()=>{
    deleteSubtask(task.id, subtask.id);
  });
  subBtnGroup.appendChild(subDeleteBtn);
  subDiv.appendChild(subBtnGroup);
  return subDiv;
}
  
/* サブタスク操作 */
function addSubtask(taskId, subtaskName) {
  const task = tasks.find(t => t.id === taskId);
  if(!task) return;
  if(!task.subtasks) task.subtasks = [];
  task.subtasks.push({
    id: Date.now(),
    name: subtaskName,
    startTime: 0,
    elapsedTime: 0,
    running: false
  });
  renderAll();
  saveToLocalStorage();
}
function toggleSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  const subtask = task.subtasks.find(s => s.id === subtaskId);
  if(!subtask) return;
  if(!subtask.running){
    subtask.running = true;
    subtask.startTime = Date.now();
    startGlobalTimer();
  } else {
    const now = Date.now();
    subtask.elapsedTime += (now - subtask.startTime);
    subtask.running = false;
  }
  renderAll();
  saveToLocalStorage();
}
function resetSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  const subtask = task.subtasks.find(s => s.id === subtaskId);
  if(!subtask) return;
  subtask.running = false;
  subtask.elapsedTime = 0;
  subtask.startTime = 0;
  renderAll();
  saveToLocalStorage();
}
function deleteSubtask(taskId, subtaskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task || !task.subtasks) return;
  task.subtasks = task.subtasks.filter(s => s.id !== subtaskId);
  renderAll();
  saveToLocalStorage();
}
  
/* サブタスク領域の折りたたみ toggle */
function toggleSubtasksCollapse(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if(!task) return;
  task.subtasksCollapsed = !task.subtasksCollapsed;
  renderAll();
  saveToLocalStorage();
}
  
/* ================================
   スナップショット機能
   - takeSnapshot(): 現在の状態を指定した日付で保存
   - loadSnapshot(): 指定スナップショットの状態を復元
   - renderSnapshotList(): snapshotDateInput の値に一致するスナップショットのみ表示
================================ */
function takeSnapshot(){
  const dateStr = snapshotDateInput.value;
  if(!dateStr){
    alert("スナップショットの日付を指定してください");
    return;
  }
  const now = new Date();
  const label = `Snapshot ${now.toLocaleString()} (${dateStr})`;
  const snap = {
    id: Date.now(),
    label,
    createdAt: now.getTime(),
    snapshotDate: dateStr,
    data: {
      tasks: structuredClone(tasks),
      collapsedCategories: structuredClone(collapsedCategories),
      knownCategories: structuredClone(knownCategories),
      categoryOrder: structuredClone(categoryOrder),
      categoryColors: structuredClone(categoryColors)
    }
  };
  snapshots.push(snap);
  saveToLocalStorage();
  alert(`スナップショットを保存しました: ${label}`);
  renderSnapshotList();
}
function loadSnapshot(snapId){
  const snap = snapshots.find(s => s.id === snapId);
  if(!snap){
    alert("該当スナップショットが見つかりません");
    return;
  }
  tasks = snap.data.tasks || [];
  collapsedCategories = snap.data.collapsedCategories || {};
  knownCategories = snap.data.knownCategories || [];
  categoryOrder = snap.data.categoryOrder || [];
  categoryColors = snap.data.categoryColors || {};
  loadedSnapshotDate = snap.snapshotDate || "";
  alert(`スナップショット「${snap.label}」を読み込みました`);
  renderAll();
  if(tasks.some(t => t.running)){
    startGlobalTimer();
  }
}
function renderSnapshotList(){
  snapshotListDiv.innerHTML = "";
  const selectedDate = snapshotDateInput.value;
  let filtered = [];
  if(selectedDate){
    filtered = snapshots.filter(snap => snap.snapshotDate === selectedDate);
  } else {
    filtered = snapshots;
  }
  if(filtered.length === 0){
    snapshotListDiv.textContent = "(該当するスナップショットがありません)";
    return;
  }
  filtered.forEach(snap => {
    const btn = document.createElement("button");
    btn.textContent = snap.label;
    btn.addEventListener("click", ()=>{
      loadSnapshot(snap.id);
      renderSnapshotList();
    });
    snapshotListDiv.appendChild(btn);
  });
}
  
/* ================================
   タイマー (60fps 更新)
================================ */
function renderRunningState(){
  let anyRunning = false;
  const categories = getOrderedCategories();
  categories.forEach((cat, catIndex) => {
    const catTasks = tasks.filter(t => t.category === cat);
    let sumMs = 0;
    const now = Date.now();
    catTasks.forEach(task => {
      let base = task.elapsedTime;
      if(task.running){
        base += (now - task.startTime);
        anyRunning = true;
      }
      // 親タスクにサブタスクがある場合、親の時間はサブタスク合計
      if(task.subtasks && task.subtasks.length > 0){
        let subTotal = 0;
        task.subtasks.forEach(st=>{
          let stBase = st.elapsedTime;
          if(st.running){
            stBase += (now - st.startTime);
            anyRunning = true;
          }
          subTotal += stBase;
        });
        base = subTotal;
      }
      sumMs += base;
    });
    const catCard = categoriesContainer.children[catIndex];
    if(catCard){
      const catInfo = catCard.querySelector('.cat-info');
      if(catInfo){
        const sumSpan = catInfo.querySelector('.cat-sum-time');
        if(sumSpan){
          sumSpan.textContent = `合計時間: ${formatTime(sumMs)}`;
        }
      }
    }
    if(!collapsedCategories[cat]){
      const taskList = catCard.querySelector('.task-list');
      if(taskList){
        const taskCards = taskList.querySelectorAll('.task-card');
        taskCards.forEach((card, i) => {
          const task = catTasks[i];
          if(!task)return;
          const timeDiv = card.querySelector('.time-display');
          if(task.subtasks && task.subtasks.length > 0){
            let subTotal = 0;
            task.subtasks.forEach(st=>{
              let stBase = st.elapsedTime;
              if(st.running){ stBase += (Date.now() - st.startTime); }
              subTotal += stBase;
            });
            timeDiv.textContent = formatTime(subTotal);
          } else {
            const btnGroup = card.querySelector('.btn-group');
            const startStopBtn = btnGroup ? btnGroup.children[0] : null;
            if(task.running){
              const now = Date.now();
              timeDiv.textContent = formatTime(task.elapsedTime + (now - task.startTime));
              if(startStopBtn){
                startStopBtn.className = 'stop-btn';
                startStopBtn.textContent = 'STOP';
              }
            } else {
              timeDiv.textContent = formatTime(task.elapsedTime);
              if(startStopBtn){
                startStopBtn.className = 'start-btn';
                startStopBtn.textContent = 'START';
              }
            }
          }
          // サブタスク更新
          if(task.subtasks && task.subtasks.length > 0){
            const subtaskDivs = card.querySelectorAll('.subtask-card');
            task.subtasks.forEach((st, subIndex) => {
              const subDiv = subtaskDivs[subIndex];
              if(subDiv){
                const subTimeDiv = subDiv.querySelector('.subtask-time');
                if(st.running){
                  subTimeDiv.textContent = formatTime(st.elapsedTime + (Date.now() - st.startTime));
                } else {
                  subTimeDiv.textContent = formatTime(st.elapsedTime);
                }
              }
            });
          }
        });
      }
    }
  });
  if(!anyRunning){
    clearInterval(globalTimerId);
    globalTimerId = null;
  }
}
function startGlobalTimer(){
  if(globalTimerId)return;
  globalTimerId = setInterval(()=>{ renderRunningState(); }, 16);
}
  
/* 現行状態の保存 */
function saveCurrentState(){
  mainData.tasks = tasks;
  mainData.collapsedCategories = collapsedCategories;
  mainData.knownCategories = knownCategories;
  mainData.categoryOrder = categoryOrder;
  mainData.categoryColors = categoryColors;
  saveToLocalStorage();
}
  
/* CSVエクスポート (UTF-8 BOM付き) */
function exportCsv(){
  const dateStr = loadedSnapshotDate || new Date().toLocaleDateString();
  const lines = [];
  lines.push("Category,Date,TaskName,Time,CategoryTotal");
  const catMap = new Map();
  tasks.forEach(t=>{
    if(!catMap.has(t.category)){
      catMap.set(t.category, getCategoryTotalTime(t.category));
    }
  });
  tasks.forEach(t=>{
    let base = t.elapsedTime;
    if(t.running){
      base += (Date.now() - t.startTime);
    }
    const timeStr = formatTime(base);
    const catTotalStr = formatTime(catMap.get(t.category) || 0);
    const row = [
      `"${t.category}"`,
      `"${dateStr}"`,
      `"${t.name}"`,
      `"${timeStr}"`,
      `"${catTotalStr}"`
    ].join(",");
    lines.push(row);
  });
  const csvContent = lines.join("\r\n");
  const bom = "\uFEFF";
  const blob = new Blob([bom + csvContent], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `Stopwatch_${dateStr}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
  
/* ================================
   ページ閉じるとき
================================ */
window.addEventListener('beforeunload', ()=>{
  const now = Date.now();
  tasks.forEach(t=>{
    if(t.running){
      t.elapsedTime += (now - t.startTime);
      t.running = false;
    }
    if(t.subtasks){
      t.subtasks.forEach(st=>{
        if(st.running){
          st.elapsedTime += (now - st.startTime);
          st.running = false;
        }
      });
    }
  });
  saveToLocalStorage();
});
  
/* 初期化 */
window.addEventListener('DOMContentLoaded', ()=>{
  loadFromLocalStorage();
  renderAll();
  renderSnapshotList();
  if(tasks.some(t=> t.running)){
    startGlobalTimer();
  }
});
  
/* イベントハンドラ */
manualSaveBtn.addEventListener('click', ()=>{
  saveToLocalStorage();
  alert("手動で保存しました。");
});
addTaskBtn.addEventListener('click', ()=>{
  const cat = categoryInput.value.trim();
  const nm = taskNameInput.value.trim();
  addTask(cat, nm);
  categoryInput.value = "";
  taskNameInput.value = "";
  categoryInput.focus();
});
stopAllBtn.addEventListener('click', stopAllTasks);
resetAllBtn.addEventListener('click', resetAllTasks);
exportCsvBtn.addEventListener('click', exportCsv);
takeSnapshotBtn.addEventListener('click', takeSnapshot);
snapshotDateInput.addEventListener('change', renderSnapshotList);
</script>
</body>
</html>
